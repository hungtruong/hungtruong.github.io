WEBVTT

00:00:00.000 --> 00:00:05.834
Making an iOS Zwift Clone to Save $15 a Month! Part 1: Core Bluetooth

00:00:07.334 --> 00:00:09.971
Published on March 17, 2019.

00:00:10.971 --> 00:00:19.761
It’s been a while since I’ve worked on a personal project, but I’ve been having an itch to make some new iOS apps and yesterday morning I decided to go ahead and hack something together.

00:00:20.761 --> 00:00:28.833
I recently purchased an exercise bike called the BikeErg (I think the name has something to do with the rowing machines that the manufacturer also makes).

00:00:29.333 --> 00:00:41.241
The bike has a built-in computer that keeps track of things like watts (apparently cycling is a sport that has really good analytics since it’s easy to track raw power), calories burned, cadence and other stuff.

00:00:41.741 --> 00:00:46.216
You can view the data on the monitor or use an app like Zwift to do workouts.

00:00:47.216 --> 00:00:53.129
I’ve been using the BikeErg to exercise pretty regularly now, and I tried a bunch of different apps that can connect to it.

00:00:53.629 --> 00:01:02.100
Zwift is pretty much the gold standard as it has many features like 3D avatars and environments, a rich community, and lots of different workout plans for you to try.

00:01:02.600 --> 00:01:12.110
Zwift integrates with apps like MyFitnessPal and Strava, too, so I can trick people into thinking that I’ve ridden in Central Park one day and London the next.

00:01:13.110 --> 00:01:18.624
While I think the feature set of Zwift is really compelling, I’m more of an old school app user.

00:01:19.124 --> 00:01:21.442
I don’t really care about the online community.

00:01:21.942 --> 00:01:26.896
I don’t really need to look at my avatar riding his bike around a futuristic city or an exploding volcano.

00:01:27.396 --> 00:01:32.111
I just want to do some directed workouts and maybe track my heart rate and my calories burned.

00:01:32.611 --> 00:01:40.043
The price of $15 a month is probably fine for people who use all of those features and get the value out of it, but I feel like I do not.

00:01:41.043 --> 00:01:53.191
Just to be clear here, I do think app developers deserve to be paid for their work and it’s definitely within reason for Zwift to charge this subscription given the sheer amount of support they need to provide to all of their users’ varying setups.

00:01:53.691 --> 00:01:59.444
After just implementing a small proof of concept, I have some mad respect for their dev team.

00:02:00.444 --> 00:02:06.678
However, I am cheap and I’m an iOS developer so I figured, “maybe I can roll my own fake Zwift!”

00:02:07.678 --> 00:02:09.356
Enter CoreBluetooth

00:02:10.856 --> 00:02:19.806
I’ve been interested in Bluetooth development ever since CoreBluetooth was added to the iOS 5.0 SDK (I think the first supported device was the iPhone 4s).

00:02:20.306 --> 00:02:28.378
But every time I tried to sit down and read the documentation I got discouraged by the complexity and ended up getting distracted by some other new shiny API.

00:02:28.878 --> 00:02:36.789
Since I had a desired use case here: Make a Zwift alternative for myself, I was able to focus up some more and get something working.

00:02:37.789 --> 00:02:46.180
While the Bluetooth protocol is incredibly flexible, that flexibility also makes it incredibly complicated to get even a simple proof of concept working.

00:02:46.680 --> 00:02:50.676
If you don’t know what the special Bluetooth jargon means, it can seem really confusing.

00:02:51.176 --> 00:02:57.729
I still don’t really understand all of it but I’ve managed to hack something together that will serve as a basis for my fake Zwift app.

00:02:58.729 --> 00:03:07.759
Rather than bore you with the technical jargon and steps required to make this app, I’d rather just go through my process of figuring it out, which may be slightly more interesting.

00:03:08.759 --> 00:03:10.357
Of course it’s called a “Manager”

00:03:11.857 --> 00:03:21.128
So the first thing I did was go to this document (which I guess is deprecated now but I didn’t notice that message when I was reading it) which goes over the Core Bluetooth framework.

00:03:22.128 --> 00:03:29.160
I found out that I needed to create a CBCentralManager, so I did that and then I tried to scan for some Bluetooth devices:

00:03:30.160 --> 00:03:38.631
let centralManager = CBCentralManager() self.centralManager.scanForPeripherals(withServices: nil, options: nil)

00:03:39.631 --> 00:03:44.666
I immediately got an error that I couldn’t do that since the centralManager wasn’t powered on yet.

00:03:45.166 --> 00:03:53.956
Oops! I then set the delegate of the centralManager and waited for the method “centralManagerDidUpdateState” to check that it was powered on before scanning.

00:03:54.956 --> 00:04:02.388
I soon started getting a bunch of peripherals in my next delegate method, “centralManager(_:didDiscover:advertisementData:rssi:)”

00:04:03.388 --> 00:04:15.136
Among the things I found were my laptop (over and over again even though the scan was set to not allow duplicates…), someone’s Bluetooth headset and various other things I couldn’t identify. Success!

00:04:16.136 --> 00:04:24.687
Once I filtered out the peripherals that kept on repeating, I was able to turn on the bike (by cycling a bit) and I got this message in my logs:

00:04:25.687 --> 00:04:28.324
I successfully found my PM5.

00:04:28.824 --> 00:04:30.982
Now to connect to it and get the data.

00:04:31.482 --> 00:04:34.518
I ended up connecting to the PM5 based on the name.

00:04:35.018 --> 00:04:47.646
(After doing some reading it looks like I could connect based on the last service UUID of “CE060000-43E5-11E4-916C-0800200C9A66”).

00:04:48.646 --> 00:04:57.836
I called the “connect” function of the centralManager and later got an error because the peripheral wasn’t retained (I guess the Central doesn’t keep a strong reference, which makes sense).

00:04:58.336 --> 00:05:02.651
I tried again, this time keeping a reference to the peripheral in an array.

00:05:03.651 --> 00:05:06.288
Peripherals, Services and Characteristics

00:05:07.788 --> 00:05:11.704
Once I connected, I had to discover the peripheral’s services.

00:05:12.204 --> 00:05:16.439
And once that succeeded I had to discover each service’s characteristics.

00:05:16.939 --> 00:05:24.051
Once you discover those characteristics you can set the peripheral’s services’ characteristics to “notify” you when the characteristic changes.

00:05:24.551 --> 00:05:25.271
In more depth:

00:05:26.271 --> 00:05:30.266
Connect to peripheral using the central’s “connect(_:options:)” method and retain it

00:05:31.266 --> 00:05:39.657
Handle the “ centralManager(_:didConnect:) ” delegate method where you set the peripheral’s delegate and call its “discoverServices(_:)” method

00:05:40.657 --> 00:05:51.926
Handle the “peripheral(_:didDiscoverServices:)” delegate method and call the peripheral’s “discoverCharacteristics(_:for:)” for each service you want to discover characteristics for (why not all of them at this point?)

00:05:52.926 --> 00:06:06.112
Handle the “peripheral(_:didDiscoverCharacteristicsFor:error:)” delegate method for each service’s characteristics you wanted to discover by calling the peripheral’s “setNotifyValue(_:for:)” method on each service’s characteristic that you want notifications for.

00:06:07.112 --> 00:06:17.262
Optionally handle the “peripheral(_:didUpdateNotificationStateFor:error:)” method to see if you were able to successfully update the notification state for each peripheral’s service’s characteristic.

00:06:17.762 --> 00:06:23.356
In some cases I wasn’t able to ask for updates, perhaps those characteristics are just static data?

00:06:24.356 --> 00:06:32.667
Handle the “peripheral(_:didUpdateValueFor:error:)” method to get the updated value for each characteristic that you wanted notifications for.

00:06:33.667 --> 00:06:45.655
This all seems really convoluted to me and it was probably part of the reason that I always gave up on implementing Bluetooth in the past, but I think that’s more of a symptom of the complexity of the Bluetooth protocol than the CoreBluetooth API.

00:06:46.655 --> 00:06:51.369
Now all I needed to do was generate some data by cycling on the bike for a few seconds.

00:06:51.869 --> 00:06:53.947
I wasn’t quite finished yet, though.

00:06:54.447 --> 00:07:01.639
When the characteristics are updated and you start getting notified, you can inspect the new values, but those values are just Data objects .

00:07:02.139 --> 00:07:09.491
Each characteristic can hold a number of values based on how the data is structured, and that is up to whoever is implementing the Bluetooth protocol.

00:07:10.491 --> 00:07:16.325
I did some research and found this document that describes the Bluetooth specifications for the PM5 device.

00:07:17.325 --> 00:07:27.874
In that document were some tables including the one above which describes the UUID for a characteristic that includes things like elapsed time, calories, and most importantly, watts.

00:07:28.374 --> 00:07:35.966
I discovered that the data was being encoded into bytes, so I took the raw Data object and split it into an array of 8-bit Integers.

00:07:36.466 --> 00:07:39.902
Once I started printing those arrays I saw something like this:

00:07:40.902 --> 00:07:46.256
Because the PM5 was originally set up for rowing machines, the documentation is a bit confusing.

00:07:46.756 --> 00:07:50.432
It refers to “strokes” which might line up with rpms on a bike?

00:07:50.932 --> 00:07:58.045
I was mainly interested in watts for my proof of concept so I found a few values in the document that mentioned watts.

00:07:58.545 --> 00:08:04.378
The table in the spec mentions “Stroke Power Lo (watts)” and has a “Stroke Power Hi” (what’s the difference?).

00:08:04.878 --> 00:08:10.392
I cobbled an interface together to test out my guess about the first value and here’s the video result:

00:08:11.392 --> 00:08:15.707
Success! I’m now able to connect my phone to my bike with my app.

00:08:16.207 --> 00:08:22.840
I have only gotten the wattage data from the bike so far, but reading through the spec it seems like there is a lot more I can pull via Bluetooth.

00:08:23.340 --> 00:08:31.731
I already know from using Zwift that I can get cadence from the bike, for example, and I saw a few other interesting things like calories, pace and distance traveled.

00:08:32.731 --> 00:08:36.887
Every Journey Begins With a Single CoreBluetooth Implementation

00:08:38.387 --> 00:08:43.581
I titled this blog post “Part 1” in a series but I don’t know when the next step will be.

00:08:44.081 --> 00:08:45.759
My wishlist is:

00:08:46.759 --> 00:08:51.314
I want to eventually set up directed workouts in a similar fashion as Zwift

00:08:52.314 --> 00:08:58.148
I also want to be able to track my heart rate which I can do by writing an Apple Watch app for my existing app

00:08:59.148 --> 00:09:02.983
I want to be able to store my workout data and integrate with Apple Health

00:09:03.983 --> 00:09:07.499
I want to import workouts or at least create them inside of the app

00:09:08.499 --> 00:09:15.212
I want to chart the actual wattage of the bike against the guided wattage, and also show heart rate, and show histograms

00:09:16.212 --> 00:09:17.970
I want to avoid feature creep

00:09:18.970 --> 00:09:25.363
I haven’t figured out which order to do these things in but for now I’ll continue to use Zwift since I already paid for the membership.

00:09:25.863 --> 00:09:35.213
My next step is probably to break out the code for connecting to the PM5 into its own project and make all of the data from it available in an easy to consume form.

00:09:35.713 --> 00:09:39.949
I’m kinda torn between that and just making the MVP for doing workouts.

00:09:40.949 --> 00:09:47.661
If I had to estimate, I probably spent more than 3 hours working on this project so far and more on writing this blog post.

00:09:48.161 --> 00:09:55.194
If I was to value my time based on what my contracting rate would be I’d probably be able to pay for more than a year of Zwift with it!

00:09:55.694 --> 00:10:01.847
So this project is really more about learning different iOS technologies than it is about saving money at this point.

00:10:02.847 --> 00:10:05.964
If you found this blog post interesting let me know!

00:10:06.464 --> 00:10:12.457
I wanted to write down my process so I could remember it, but hopefully it’s useful to anyone trying to implement CoreBluetooth.

00:10:12.957 --> 00:10:20.229
I found a bunch of sample code that connects to heart rate monitors but I didn’t find any that go through the process of writing code to a spec document.

00:10:20.729 --> 00:10:26.883
If you want to try to run this app yourself (and you happen to have the same exact bike as me), check out the source code here .
